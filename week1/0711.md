
# 0711

## 오늘 한 일

- 경로 파싱 책임 분리
- jmeter 테스트
  - http keep-alive
  - 병목 발견
- 부족한 점


## PathResolver로 요청 경로 파싱 책임 분리

Spring 프레임워크의 DispatcherServlet은 HTTP 요청을 받아 알맞은 컨트롤러에 위임하기 위해 내부적으로 경로 파싱 및 매핑을 수행한다. 

이를 참고하여 과제에서도 요청 경로를 분석하는 책임을 하나의 클래스로 분리해보기로 했다.

기존에는 HttpRequestFactory 등에서 요청 경로를 직접 해석하고 정적 파일인지, 동적 요청인지 판단하는 로직을 포함하고 있었다. 

이 방식은 클래스 간 결합도를 높이고, 확장에 불리했다. 

그래서 요청 경로를 해석하는 책임만을 가지는 PathResolver 클래스를 새롭게 정의했다. 
이 클래스는 URL 경로 문자열을 받아 정규화하거나, 정적/동적 요청을 구분하는 등의 역할을 담당할 것이다.

해당 클래스를 싱글톤으로 관리하며 애플리케이션 전체에서 공유할 수 있게 했다. 
경로 해석이라는 작업은 상태를 가지지 않기 때문에 인스턴스를 매번 생성할 필요가 없다고 판단했다. 
추후 기능에 따른 경로 매핑 기능을 도입할 경우에도 이 클래스를 수정하거나 대체하는 방식으로 유연하게 대응할 수 있을 것이다.


### 느낀 점

과제를 수행하면서 프레임워크 내부 동작을 역설계하고 구조적으로 고민해보는 경험이 흥미로웠다. 
책임을 어떻게 분리할 것인지, 확장과 유지보수를 얼마나 고려 할 것인지 고민하며 Spring 프레임워크에 철학을 살펴보았다.
또한, PathResolver처럼 별도의 클래스로 역할을 분리하니 코드의 가독성이 좋아지고 변경에도 유연하게 대응할 수 있겠다는 생각을 하게 됐다.

이를 통해 Spring이 왜 DispatcherServlet을 만들었는지, 왜 각 역할을 나눠 설계했는지를 어느정도 알 수 있었다. 이번 경험을 통해 단순 구현보다도 설계와 책임 분리의 중요성을 다시금 느꼈다.

## jmeter를 이용한 부하 테스트

적정한 쓰레드 수를 고르기 위해 부하테스트를 수행했다.
Mac Pro가 제공하는 코어를 그대로 사용하는 거 보다는 코어 수 를 제한하는게 적합하다고 생각했다.

> why?
> 실제 서비스 환경은 제한적인 리소스를 제공한다. 
> 
> 제한된 CPU 코어, 제한된 메모리, 제한된 네트워크 환경에서 애플리케이션이 얼마나 견고하게 작동하는지를 확인해야 의미 있는 테스트가 될 수 있다. 
> 또한, JVM의 GC, 컨텍스트 스위칭 비용, 공유 자원 접근 비용 등은 단순히 코어 수를 늘린다고 해결되지 않기 때문에 현실적인 한계를 설정하는 것이 중요했다.

### 테스트 결과를 보며

- ThreadPool 100은 과도한 스레드 생성으로 성능이 저하된다.
- CPU 리소스보다 ThreadPool 조정이 우선 고려 요소인 것 같다.
- ThreadPool이 너무 크면, 오히려 스레드 간 충돌, Lock 경쟁, 스케줄링 지연 등의 부작용이 발생한다.


#### 코어 수를 늘렸는데 왜 성능이 떨어지지?
- 아마도 멀티스레드 환경에 대한 성능을 제대로 생각하지 않고 설계한 것 같다.
- 공유자원에 대한 접근, Lock 등을 고려하지 않고 설계해서 문제가 있다.
- 특히, 정적 파일 처리나 요청 경로 처리 등에서 동기화되지 않은 코드가 공통 자원을 참조하거나, GC 부하가 커졌을 가능성도 있다.

#### 물론 모두 예측일 뿐이므로 명확한 원인 분석이 필요하다.

- ThreadPool 크기에 따른 TPS/Latency 변화 로그를 수집하고 정리하기 
- 정적 파일 처리/경로 파싱 등의 공통 로직에서 공유 자원 여부 및 동기화 필요성 확인하기 
- GC 로그를 활성화하고 메모리 할당 및 GC 시간 확인해보기

---
## Http : keep-alive
테스트 초반에 한 삽질

JMeter로 부하 테스트를 진행했을 때, 정확히 절반의 요청이 실패하는 이상한 현상이 발생했다.
알고 보니 JMeter의 keep-alive 옵션이 켜져 있었고, 내 서버는 이 옵션을 고려하지 않아 소켓을 닫은 상태에서 클라이언트가 재사용을 시도한 것이었다.

> HTTP keep-alive란? 
> 
> 클라이언트와 서버 간의 TCP 연결을 일정 시간 유지하면서 여러 요청을 같은 커넥션으로 처리할 수 있도록 하는 옵션이다. 
> 
> 새로운 연결을 만들지 않기 때문에 TCP 핸드셰이크 비용을 줄이고, 처리량을 증가시킬 수 있다.


이 경험을 통해 내 서버도 keep-alive를 지원하도록 수정해야겠다고 느꼈다.

HTTP/1.1은 기본적으로 Connection: keep-alive를 사용하며, 명시적으로 close를 지정하지 않으면 연결을 유지하는 것이 표준이다.

#### todo

- 응답 헤더에 Connection: keep-alive를 명시적으로 추가하기 
- 요청 헤더에서 Connection: close가 있는 경우만 소켓 닫기 
- keep-alive가 설정된 커넥션에 대해 요청 종료 후에도 InputStream을 재사용할 수 있는 구조로 리팩토링하기
- keep-alive timeout 설정 (예: 5초) 및 유휴 커넥션 정리 로직 추가
- JMeter 테스트 시 keep-alive on/off 결과 비교하기

---

### 부족한 점

WAS를 구현해보겠다며 의욕적으로 시작했지만, 정작 기본인 HTTP 규약조차 제대로 지키지 못했다.

요청 파싱 시 공백이나 대소문자 처리처럼 중요한 부분을 놓쳤고, 요구사항도 충분히 반영하지 못한 채 객체지향만 고민하고 있었다는 점에서 오만했다는 반성을 하게 됐다.

기초부터 제대로 하지 않으면 어떤 설계도 무의미하다.









