

## 멘토링 회고

### 카페 도메인 분석을 하면서 느낀 점

#### 도메인 분석
- 내가 잘 모르는 부분을 상상하면서 하는건 고된 일이다.
- 개발자가 도메인을 공부한들 현장과는 다를 수 있다.
- 기획자, 디자이너, 도메인 전문가에게 조언을 구하자.

#### 개발자끼리의 관점 차이
- 분명 도메인에 대해 아는 부분은 비슷하다. 그런데 이를 분석하는 방법이 많이 다르다.
- 의견을 나누면서 느낀 점은 그들의 분석이 결코 틀리지 않다는 것이다. 관점이 다른 것이다.
- 협업이란 관점의 차이를 존중하며 합의를 이뤄내는 과정이다.

### DDD (Domain-Driven Design)의 중요성
- DDD는 기술이 아닌 비즈니스의 복잡성을 이해하고 모델링하는 데 집중하는 설계 철학이다.
- 도메인 전문가와의 협업을 통해 문제의 본질을 파악하고, 구조를 코드에 녹여내는 것이다.
- 이를 통해 개발자는 기능 구현에만 집중하지 않고, 비즈니스 가치에 부합하는 시스템을 만들 수 있다.
- 결국 DDD는 더 나은 커뮤니케이션, 그리고 도메인에 특화된 유연한 설계로 이어진다.

### Dangle의 한마디

1. 현업자의 도메인 지식을 무시하지 말라.
  - 기획자, 디자이너의 의견을 존중하라
  - 도메인 전문가의 조언을 구하라.

2. 개발자들끼리의 토론
  - 생각이 달라질 수 있음을 인정하자.
  - 상대방이 나랑 다른 생각을 갖고 있음을 인정하라.
--- 
## 과제 회고

### HttpServlet
- Servlet을 추상화하고, 클라이언트의 요청에 적합한 Servlet을 반환하자.
- 그럼 우선 Servlet의 역할부터 정의해야 한다.
    - Servlet은 요청(HttpRequest)을 처리하고, 그에 대한 응답(HttpResponse)을 생성하는 역할을 한다. 이를 통해 개별 요청마다 로직을 분리할 수 있다.
- 일단 `service()` 라는 메소드 하나만 선언한다.
  > #### why?
  > - 현재 요구사항 수준에서는 단일 진입점이 필요할 뿐이다. 
  > - 실제로 톰캣도 `service()`가 최상위 메소드이며, doGet/doPost는 그 이후 분기라고 한다. 
  > - GET/POST에 대한 분기 로직이 필요하게되면 다시 고민해보자.

### StaticServlet
- 정적 리소스 요청에 경로별로 다른 서블릿으로 대응하는 건 비효율적이라 생각했다.
  > #### why?
  > - 파일 개수만큼 서블릿을 만들 수도 없고, URL 경로와 파일 이름이 1:1로 매핑되는 구조에서는 로직이 동일하다. 비슷한 코드만 반복될것 같다.
- 경로를 파싱해서 해당 경로에 파일이 있으면 파일을 반환하고 없으면 404 파일을 반환하자.
  > #### why?
  > 파일 존재 여부만으로 응답이 갈리기 때문에 로직이 단순해지고, 확장에도 유리하다. 
  > 새로운 HTML이나 CSS를 추가할 때 서블릿을 추가할 필요 없이 파일만 두면 된다.

### ServerConfig와 쓰레드풀
- 내장 톰캣의 MaxThread는 기본값이 200이다. 일단 따라하자.
- 근데 왜 톰캣은 200개나 쓰지? 보통 코어가 1~16개일 텐데..
    - I/O 작업이 많은 웹 서버 특성상, 실제 CPU를 점유하는 시간보다 대기 시간이 훨씬 길다고 한다. 
    - 예를 들어 DB, 파일, 네트워크 응답을 기다리는 동안 스레드는 대부분 블로킹 상태다. 
    - 이런 상황을 고려해 다수의 요청을 동시에 처리하려면, 코어 수보다 많은 스레드를 할당해도 문제가 되지 않는다. 
    - 실제 동시 접속 처리를 위해선 수백 개의 스레드가 필요하다.


### 쓰레드 구조 고민

- 현재 구조는 요청마다 새로운 스레드를 생성한다.
- 요구사항에도 "멀티스레드 개선"이 명시되어 있었기에, `ExecutorService` 기반의 스레드풀을 도입했다.

> **왜 스레드풀이 필요한가?**
> - 요청마다 Thread를 새로 생성하면 메모리 낭비, GC 부담, 응답 지연 등이 발생할 수 있다.
> - 웹 서버는 대부분 I/O 블로킹 시간이 많아 CPU 코어 수보다 많은 스레드가 필요할 수 있다.
> - 톰캣의 기본 스레드 수가 200인 것도 이러한 이유 때문이다.

- 그러면 지금 200개일 필요가 있을까? 지금은 I/O 가 없다 줄이자.
- 내 맥북의 코어수? 10개다.


**ExecutorService란?**
> 원래 Java에서 멀티스레드를 다룰 때 관성적으로 ExecutorService를 사용했다.
> 이 참에 왜쓰는지 알아보자.

Java 1.5부터 java.util.concurrent 패키지가 도입되면서,
스레드를 효율적으로 관리할 수 있는 Executor Framework가 제공되었고, 그 핵심 인터페이스가 ExecutorService다 : [링크](https://velog.io/@genius00hwan/%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-ExecutorService%EC%9D%98-%EB%93%B1%EC%9E%A5)


| 항목         |설명|
|------------|---|
| 스레드 재사용    |반복적인 생성과 소멸 없이 풀에서 재사용|
| 병렬성 제어	    | 스레드 수 제한으로 자원 낭비 방지|
| 코드 간결화     |	작업 제출 중심의 구조로 코드 단순화 |
| 예외 및 결과 처리 |	Future로 비동기 결과 추적 가능|
|  안전한 종료    |	shutdown() 등으로 자원 누수 방지|


### HttpRequestLogger라는 유틸성 클래스를 따로 만든 이유
- HttpRequest 내부에서 로그를 찍게 되면 책임이 모호해진다. 파싱과 로깅이 섞이게 되므로, 관심사를 분리하는 것이 맞다고 생각했다.
- 또한 로깅 포맷을 유연하게 바꾸고 싶을 때, 별도 클래스를 통해 변경이 쉬워진다.


### 생성자 주입 vs Setter 주입 - Container
- 생성자 주입은 객체가 생성될 때 필수로 필요한 의존성을 강제할 수 있다는 장점이 있다. 불변성을 보장하고, DI 구조도 명확하다.
- Setter 주입은 선택적인 의존성이나, 순환 참조를 피해야 할 경우 활용할 수 있지만, 테스트나 유지보수 측면에서 혼란을 줄 수 있다.
- 이번 구조에서는 Container가 생성될 때 StaticServlet이 기본으로 제공되게끔 생성자 주입이 적절하다고 생각했다.
  > 왜?
  > - staticServlet은 fallback 처리를 담당하는 핵심 컴포넌트다.
  > - 이는 ServletContainer가 생성될 때 반드시 설정되어야만 하며, 이후에 동적으로 변경될 필요도 없다.
  > - 생성자 주입을 통해 불변성을 보장하고, 필수 의존성을 명확히 드러낼 수 있다고 판단했다.

### 새로운 고민 : 왜 톰캣을 쓰지?

결국 톰캣을 따라가는 이유는 명확하다:
- Java 웹 생태계에서 Servlet 기반 구조는 표준이다.
- Spring Boot는 내장 톰캣을 전제로 설계되어 있다.
- 개발자 입장에서 가벼우면서 간편하다.
- 학습·테스트·확장 모두에 유리한 검증된 구조이이다.

[왜 톰캣인가?](https://velog.io/@genius00hwan/%EC%99%9C-%ED%86%B0%EC%BA%A3%EC%9D%B8%EA%B0%80)

-> 그래서 이번 과제에서는 톰캣의 구조를 흉내 내며 구현을 이어가기로 했다.

### append : 패키지 구조
>
> - container
>   - ServletContainer
>   - ServletContainerConfig
> - message
>   - HttpRequest
>   - HttpResponse
> - servlet
>   - HttpServlet
>   - StaticServlet
> - utils
>   - HttpRequestLogger
> - webserver
>   - RequestHandler
>   - ServerConfig
>   - WebServer