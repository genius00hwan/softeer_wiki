

## 멘토님의 한마디

1. 현업자의 도메인 지식을 무시하지 말라.
   - 기획자, 디자이너의 의견을 존중하라

2. 개발자들끼리의 토론
   - 생각이 달라질 수 있음을 인정하자.
   - 상대방이 나랑 다른 생각을 갖고 있음을 인정하라.



--- 
## 과제 회고

### HttpServlet
- 클라이언트의 요청에 적합한 Servlet을 반환하겠지만 이를 추상화해서 사용하자.
- 그럼 우선 Servlet의 역할부터 정의해야 한다.
    - Servlet은 요청(HttpRequest)을 처리하고, 그에 대한 응답(HttpResponse)을 생성하는 역할을 한다. 이를 통해 개별 요청마다 로직을 분리할 수 있다.
- 일단 service라는 메소드 하나만 선언한다.
  > #### why?
  > - 현재 요구사항 수준에서는 단일 진입점이 필요할 뿐이다. 
  > - 실제로 톰캣도 `service()`가 최상위 메소드이며, doGet/doPost는 그 이후 분기라고 한다. 
  > - GET/POST에 대한 분기 로직이 필요하게되면 다시 고민해보자.

### StaticServlet
- 정적 리소스 요청에 경로별로 다른 서블릿으로 대응하는 건 비효율적이라 생각했다.
  > #### why?
  > - 파일 개수만큼 서블릿을 만들 수도 없고, URL 경로와 파일 이름이 1:1로 매핑되는 구조에서는 로직이 동일하다. 비슷한 코드만 반복될것 같다.
- 경로를 파싱해서 해당 경로에 파일이 있으면 파일을 반환하고 없으면 404 파일을 반환하자.
  > #### why?
  > 파일 존재 여부만으로 응답이 갈리기 때문에 로직이 단순해지고, 확장에도 유리하다. 
  > 새로운 HTML이나 CSS를 추가할 때 서블릿을 추가할 필요 없이 파일만 두면 된다.

### ServerConfig와 쓰레드풀
- 내장 톰캣의 MaxThread는 기본값이 200이다. 일단 따라하자.
- 근데 왜 톰캣은 200개나 쓰지? 보통 코어가 1~16개일 텐데..
    - I/O 작업이 많은 웹 서버 특성상, 실제 CPU를 점유하는 시간보다 대기 시간이 훨씬 길다고 한다. 
    - 예를 들어 DB, 파일, 네트워크 응답을 기다리는 동안 스레드는 대부분 블로킹 상태다. 
    - 이런 상황을 고려해 다수의 요청을 동시에 처리하려면, 코어 수보다 많은 스레드를 할당해도 문제가 되지 않는다. 
    - 실제 동시 접속 처리를 위해선 수백 개의 스레드가 필요하다.

### HttpRequestLogger라는 유틸성 클래스를 따로 만든 이유
- HttpRequest 내부에서 로그를 찍게 되면 책임이 모호해진다. 파싱과 로깅이 섞이게 되므로, 관심사를 분리하는 것이 맞다고 생각했다.
- 또한 로깅 포맷을 유연하게 바꾸고 싶을 때, 별도 클래스를 통해 변경이 쉬워진다.


### 생성자 주입 vs Setter 주입 - Container
- 생성자 주입은 객체가 생성될 때 필수로 필요한 의존성을 강제할 수 있다는 장점이 있다. 불변성을 보장하고, DI 구조도 명확하다.
- Setter 주입은 선택적인 의존성이나, 순환 참조를 피해야 할 경우 활용할 수 있지만, 테스트나 유지보수 측면에서 혼란을 줄 수 있다.
- 이번 구조에서는 Container가 생성될 때 StaticServlet이 기본으로 제공되게끔 생성자 주입이 적절하다고 생각했다.
  > 왜?
    > - staticServlet은 fallback 처리를 담당하는 핵심 컴포넌트다.
    > - 이는 ServletContainer가 생성될 때 반드시 설정되어야만 하며, 이후에 동적으로 변경될 필요도 없다. 
    > - 생성자 주입을 통해 불변성을 보장하고, 필수 의존성을 명확히 드러낼 수 있다고 판단했다. 


### 쓰레드 구조 고민

- 현재 구조는 요청마다 새로운 스레드를 생성한다.
- 요구사항에도 "멀티스레드 개선"이 명시되어 있었기에, `ExecutorService` 기반의 스레드풀을 도입했다.

> **왜 스레드풀이 필요한가?**
> - 요청마다 Thread를 새로 생성하면 메모리 낭비, GC 부담, 응답 지연 등이 발생할 수 있다.
> - 웹 서버는 대부분 I/O 블로킹 시간이 많아 CPU 코어 수보다 많은 스레드가 필요할 수 있다.
> - 톰캣의 기본 스레드 수가 200인 것도 이러한 이유 때문이다.

- 그러면 지금 200개일 필요가 있을까? 지금은 I/O 가 없다 줄이자.
- 내 맥북의 코어수? 10개다.


**ExecutorService란?**
> 원래 Java에서 멀티스레드를 다룰 때 관성적으로 ExecutorService를 사용했다.
> 이 참에 왜쓰는지 알아보자.

Java 5부터 java.util.concurrent 패키지가 도입되면서,
스레드를 효율적으로 관리할 수 있는 Executor Framework가 제공되었고, 그 핵심 인터페이스가 ExecutorService다.

- 스레드 재사용 (풀링)
  → 매 요청마다 새로 만드는 게 아니라, 기존 스레드를 재활용해서 오버헤드 감소

- 작업 제출과 실행 분리
  → Runnable이나 Callable을 큐에 제출하면, 스레드 풀에서 적절히 실행

- 작업 결과 추적
  → submit()을 통해 결과나 예외를 비동기적으로 확인 가능

- shutdown 관리 가능
  → 명시적인 종료 (shutdown()), 즉시 종료 (shutdownNow()) 등 유연하게 관리

### append : 패키지 구조
>
> - container
>   - ServletContainer
>   - ServletContainerConfig
> - message
>   - HttpRequest
>   - HttpResponse
> - servlet
>   - HttpServlet
>   - StaticServlet
> - utils
>   - HttpRequestLogger
> - webserver
>   - RequestHandler
>   - ServerConfig
>   - WebServer