# 07.10 일지

### 오늘 한 일

- response, request 리팩토링
- DI Container 만들기
- 부하테스트 세팅


## HttpMessage 리팩토링

- `HttpResponse` 클래스에 `DataOutput`이 포함된 설계가 과연 적절한가에 대한 피드백을 받았다.
- `HttpResponse`는 불변 객체로 설계했지만, 세터를 통해 상태를 변경하는 방식으로 구현되면서 설계 철학이 모호해졌다.
- 세터 방식은 테스트가 어렵고, 상태 추적이 불명확해질 수 있어 불변성을 지키는 것이 더 적절하다고 판단했다.

### 톰캣을 보며 든 의문

톰캣의 서블릿 컨테이너는 `HttpServletResponse` 객체를 서블릿에 주입하고, 개발자는 그 객체에 직접 `setStatus()`, `setHeader()`, `getWriter().write()` 등을 호출하여 응답을 구성한다.

이는 다음과 같은 방식이다:

```java
resp.setStatus(200);
resp.setHeader("Content-Type", "text/html");
resp.getWriter().write("Hello");
```

이처럼 톰캣은 응답 객체를 미리 생성하고, 공유 가능한 상태 객체로 전달하는 구조를 취하고 있다. 

그러나 이 구조는 몇 가지 측면에서 의문이 들게 한다.

#### 상태 누수와 추적의 어려움
상태를 여러 단계에 걸쳐 수정하다 보면, 응답이 어떤 순서로 구성되었는지 추적하기가 어려워진다. 특히 복잡한 필터 체인이나 다양한 서블릿 레이어가 응답 객체를 수정하는 구조에서는 디버깅이 어렵다.

불변성의 부재
상태가 언제든지 바뀔 수 있다는 것은 코드의 예측 가능성을 낮춘다. 특히 테스트나 멀티 스레드 환경에서는 문제의 원인을 파악하기 더 힘들어진다.

#### 로직이 응답 구성에 묻힌다
로직과 응답 구성이 섞이면서, 서블릿의 주요 로직이 응답 상태 설정에 파묻힐 수 있다. 이는 관심사의 분리를 어렵게 만든다.

이러한 점에서, 톰캣이 잘못된 것은 아니지만, 지금의 방식보다 더 객체지향적이고 깔끔한 방식이 있을 수 있다는 생각이 들었다. 

예를 들어, 응답을 직접 조립하지 않고 응답을 생성해 반환하는 구조로 개선되면 어떨까?

### 리팩토링 방향
서블릿이 HttpResponse 객체를 생성해서 반환하도록 구조를 변경했다.

HttpResponse는 record 기반으로 설계하여 불변 객체로 유지한다.

응답 조립은 HttpResponseFactory에서 담당하도록 위임했다.

```java
return HttpResponseFactory.ok("text/html", bodyBytes);
```
이렇게 되면 다음과 같은 이점이 있다:

응답이 불변으로 구성되어 예측 가능성이 높아진다.

테스트와 디버깅이 쉬워진다.

서블릿은 오직 비즈니스 로직에 집중하고, 응답 생성은 위임함으로써 관심사를 분리할 수 있다.

### 결론
톰캣의 방식은 과거 자바 EE 시대의 철학을 따른 설계이지만, 오늘날의 설계 관점에서는 개선의 여지가 있다고 느꼈다. 
불변 객체를 반환하는 구조는 유지보수성과 추론 가능성 측면에서 안정적인 방식이라 생각한다.
----

## DI Container 만들기

의존성 주입, 제어의 역전이라는 개념을 학습할 때는 “그런 게 있구나” 정도였지, 실제로 왜 필요한지 피부로 와닿진 않았다.
그런데 직접 서버 구조를 짜다 보니 객체 간의 관계를 명확히 하고, 관심사를 분리하는 게 점점 더 중요하다는 걸 느꼈다.

그래서 이번에 @Singleton 어노테이션부터 직접 만들고, DI Container를 구현해봤다.
DI가 왜 중요한지, IoC는 무엇을 위한 개념인지, 싱글톤은 왜 필요한지 직접 구현하면서 명확해졌다.

---
### 왜 의존성 주입인가?
서블릿을 구현하다 보면 특정 객체에 의존하는 경우가 있다
예를 들어 `StaticServlet`이 `StaticFileResolver`에 의존하고 있다면, 
직접 new 해서 생성하는 순간부터 테스트도 어렵고, 변경도 어렵고, 확장도 어렵다.

그래서 의존성을 주입하는 구조가 필요하다고 생각했다.

> 이게 왜 좋은가?
> - 테스트가 쉬워진다: 의존 객체를 쉽게 Mock으로 교체 가능해진다.
> - 변경에 유연해진다: 다른 구현체로 갈아끼울 수 있음.
> - 객체 간 결합도를 낮춘다: 구현이 아닌 추상에 의존하게 되면서 인터페이스 기반 설계가 자연스러워짐.

단순히 코드를 깔끔하게 하자는 게 아니라, 유지보수성과 확장성을 위한 판단이었다.

---

### 왜 제어의 역전인가?
보통은 필요한 의존 객체를 `new` 로 직접 만든다.
그런데 이러면 객체가 스스로 자신의 생애주기를 관리하게 된다. 의존이 명확해지는 것처럼 보여도, 실제로는 유연성이 떨어진다고 한다.

제어의 역전(IoC)은 이 제어권을 외부로 넘기는 거다.
객체는 "내가 무엇을 써야 할지" 알지 못하고, DI Container가 대신 주입해주는 구조이다.

```java
 DIContainer.initialize(
                StaticFileResolver.class,
                StaticServlet.class,
                ServletContainer.class
        );
```

> 이게 왜 좋냐면:
> - 객체는 자신의 책임에만 집중하게 되고 
> - 라이프사이클, 의존 객체 관리 등은 외부에서 통제하게 되면서 
> - 훨씬 구조적인 설계가 가능해진다.

객체가 협력하는 방식 자체가 명확해지고, 설계 파악이 명확해진다.
---

### 왜 싱글톤인가?
HTTP 요청이 들어올 때마다 `StaticServlet`이나 `FileResolver` 같은 객체가 계속 새로 만들어지면 리소스 낭비도 심하고, 관리도 복잡해진다.

사실 이런 객체들은 상태를 갖지 않기 때문에 여러 요청이 공유해도 무방핟.
그래서 자연스럽게 싱글톤으로 만들어 관리하게 된다.

DI Container에서 `@Singleton` 어노테이션 기반으로 인스턴스를 미리 생성해두고, 같은 타입에 대해선 계속 재사용하는 구조를 만든 이유이다.


### 역할 분리
`DIContainer`는 객체의 생성 책임을 가진다.

`@Singleton`은 재사용 가능한 컴포넌트임을 명시해준다.

각 객체는 자신이 어떤 의존성을 갖는지 선언만 하면 되고, 생성은 `DIContainer`가 대신 해준다.

`WebServer`나 `RequestHandler`는 단순히 필요한 객체를 받아서 로직을 수행하면 된다.

---
## 부하 테스트 자동화 세팅

멀티 스레드 기반으로 동작하는 간단한 WAS를 직접 구현하며, 실제 요청이 들어왔을 때 시스템이 어느 정도의 부하를 견딜 수 있는지를 확인해보고 싶었다. 

특히 스레드 풀의 크기, CPU 제한, 요청 수가 응답률과 에러율에 어떤 영향을 미치는지를 수치로 확인하고자 했다.

테스트 구성

- 테스트는 다음 요소를 변수로 삼아 반복적으로 수행되도록 구성했다:
- 서버 스레드 풀 크기 (THREAD_POOL_SIZE)
- 할당된 CPU 수 (--cpus 옵션으로 docker 제한)
- JMeter로 발행한 동시 요청 수 및 반복 횟수

```bash
THREADS=(10 50 100)
CPUS=(1 2 4)
JMETER_THREADS=(10 50 100)
LOOPS=10
```
각 조합마다 다음 단계를 반복했다:

THREAD_POOL_SIZE를 Build Arg로 Docker 이미지 빌드

CPU 제한과 함께 컨테이너 실행

JMeter CLI로 부하 테스트 실행

결과 .jtl 파일 저장 후 컨테이너 종료
테스트 스크립트는 자동화되어 있어, 모든 조합에 대한 결과를 반복 실행하고 파일로 저장할 수 있었다.

### 느낀 점
처음에는 단순히 부하를 많이 주면 성능 차이가 드러날 거라고 생각했지만, CPU, 스레드 풀, 요청량 간의 관계는 의외로 미묘했다.

에러율 50%가 나올 때, 단순히 서버가 느려진 게 아니라 응답 타임아웃 혹은 수신 거절 등의 문제가 포함된다는 점도 알게 되었다.

WAS의 병렬 처리 구조, 타임아웃 정책, 커넥션 관리 등을 검증하는 데 부하 테스트는 유의미한 도구라는 것을 체감했다.

 